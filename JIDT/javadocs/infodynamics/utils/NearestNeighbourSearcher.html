<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (1.7.0_181) on Sun Nov 25 23:51:49 AEDT 2018 -->
<title>NearestNeighbourSearcher</title>
<meta name="date" content="2018-11-25">
<link rel="stylesheet" type="text/css" href="../../stylesheet.css" title="Style">
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="NearestNeighbourSearcher";
        }
    }
    catch(err) {
    }
//-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar_top">
<!--   -->
</a><a href="#skip-navbar_top" title="Skip navigation links"></a><a name="navbar_top_firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../index-all.html">Index</a></li>
<li><a href="../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../infodynamics/utils/NativeUtils.html" title="class in infodynamics.utils"><span class="strong">Prev Class</span></a></li>
<li><a href="../../infodynamics/utils/NeighbourNodeData.html" title="class in infodynamics.utils"><span class="strong">Next Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../index.html?infodynamics/utils/NearestNeighbourSearcher.html" target="_top">Frames</a></li>
<li><a href="NearestNeighbourSearcher.html" target="_top">No Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../allclasses-noframe.html">All Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field_summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor_summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method_summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field_detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor_detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method_detail">Method</a></li>
</ul>
</div>
<a name="skip-navbar_top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="subTitle">infodynamics.utils</div>
<h2 title="Class NearestNeighbourSearcher" class="title">Class NearestNeighbourSearcher</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li>infodynamics.utils.NearestNeighbourSearcher</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<dl>
<dt>Direct Known Subclasses:</dt>
<dd><a href="../../infodynamics/utils/KdTree.html" title="class in infodynamics.utils">KdTree</a>, <a href="../../infodynamics/utils/UnivariateNearestNeighbourSearcher.html" title="class in infodynamics.utils">UnivariateNearestNeighbourSearcher</a></dd>
</dl>
<hr>
<br>
<pre>public abstract class <span class="strong">NearestNeighbourSearcher</span>
extends java.lang.Object</pre>
<div class="block">Generic class for fast neighbour searching
  possibly across several (multi-dimensional) variables.
 Instantiates either a sorted array for single dimension data,
  or a k-d tree for multi-dimensional / multiple variables.
 Norms for the nearest neighbour searches are the max norm between
  the (multi-dimensional) variables, and either max norm or Euclidean
  norm (squared) within each variable.</div>
<dl><dt><span class="strong">Author:</span></dt>
  <dd>Joseph Lizier (<a href="joseph.lizier at gmail.com">email</a>,
 <a href="http://lizier.me/joseph/">www</a>)</dd></dl>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- =========== FIELD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="field_summary">
<!--   -->
</a>
<h3>Field Summary</h3>
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0" summary="Field Summary table, listing fields, and an explanation">
<caption><span>Fields</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Field and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected int</code></td>
<td class="colLast"><code><strong><a href="../../infodynamics/utils/NearestNeighbourSearcher.html#normTypeToUse">normTypeToUse</a></strong></code>
<div class="block">The norm type to use between the univariates.</div>
</td>
</tr>
</table>
</li>
</ul>
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor_summary">
<!--   -->
</a>
<h3>Constructor Summary</h3>
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0" summary="Constructor Summary table, listing constructors, and an explanation">
<caption><span>Constructors</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colOne" scope="col">Constructor and Description</th>
</tr>
<tr class="altColor">
<td class="colOne"><code><strong><a href="../../infodynamics/utils/NearestNeighbourSearcher.html#NearestNeighbourSearcher()">NearestNeighbourSearcher</a></strong>()</code>&nbsp;</td>
</tr>
</table>
</li>
</ul>
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method_summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0" summary="Method Summary table, listing methods, and an explanation">
<caption><span>Methods</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static java.lang.String</code></td>
<td class="colLast"><code><strong><a href="../../infodynamics/utils/NearestNeighbourSearcher.html#convertNormTypeToString(int)">convertNormTypeToString</a></strong>(int&nbsp;normType)</code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><strong><a href="../../infodynamics/utils/NearestNeighbourSearcher.html#countPointsStrictlyWithinR(int,%20double)">countPointsStrictlyWithinR</a></strong>(int&nbsp;sampleIndex,
                          double&nbsp;r)</code>
<div class="block">As per <a href="../../infodynamics/utils/NearestNeighbourSearcher.html#countPointsWithinR(int,%20double,%20boolean)"><code>countPointsWithinR(int, double, boolean)</code></a>
 with allowEqualToR == false</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><strong><a href="../../infodynamics/utils/NearestNeighbourSearcher.html#countPointsStrictlyWithinR(int,%20double,%20int)">countPointsStrictlyWithinR</a></strong>(int&nbsp;sampleIndex,
                          double&nbsp;r,
                          int&nbsp;dynCorrExclTime)</code>
<div class="block">As per <a href="../../infodynamics/utils/NearestNeighbourSearcher.html#countPointsWithinR(int,%20double,%20int,%20boolean)"><code>countPointsWithinR(int, double, int, boolean)</code></a>
 with allowEqualToR == false</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><strong><a href="../../infodynamics/utils/NearestNeighbourSearcher.html#countPointsWithinOrOnR(int,%20double)">countPointsWithinOrOnR</a></strong>(int&nbsp;sampleIndex,
                      double&nbsp;r)</code>
<div class="block">As per <a href="../../infodynamics/utils/NearestNeighbourSearcher.html#countPointsWithinR(int,%20double,%20boolean)"><code>countPointsWithinR(int, double, boolean)</code></a>
 with allowEqualToR == true</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><strong><a href="../../infodynamics/utils/NearestNeighbourSearcher.html#countPointsWithinOrOnR(int,%20double,%20int)">countPointsWithinOrOnR</a></strong>(int&nbsp;sampleIndex,
                      double&nbsp;r,
                      int&nbsp;dynCorrExclTime)</code>
<div class="block">As per <a href="../../infodynamics/utils/NearestNeighbourSearcher.html#countPointsWithinR(int,%20double,%20int,%20boolean)"><code>countPointsWithinR(int, double, int, boolean)</code></a>
 with allowEqualToR == true</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>abstract int</code></td>
<td class="colLast"><code><strong><a href="../../infodynamics/utils/NearestNeighbourSearcher.html#countPointsWithinR(double[][],%20double,%20boolean)">countPointsWithinR</a></strong>(double[][]&nbsp;sampleVectors,
                  double&nbsp;r,
                  boolean&nbsp;allowEqualToR)</code>
<div class="block">As per <a href="../../infodynamics/utils/NearestNeighbourSearcher.html#countPointsWithinR(int,%20double,%20boolean)"><code>countPointsWithinR(int, double, boolean)</code></a>
 however the search is to match a specified sample point (not a sample
 point within the search space itself).</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>abstract int</code></td>
<td class="colLast"><code><strong><a href="../../infodynamics/utils/NearestNeighbourSearcher.html#countPointsWithinR(double[][],%20double,%20boolean,%20boolean[])">countPointsWithinR</a></strong>(double[][]&nbsp;sampleVectors,
                  double&nbsp;r,
                  boolean&nbsp;allowEqualToR,
                  boolean[]&nbsp;additionalCriteria)</code>
<div class="block">As per <a href="../../infodynamics/utils/NearestNeighbourSearcher.html#countPointsWithinR(double[][],%20double,%20boolean)"><code>countPointsWithinR(double[][], double, boolean)</code></a>
 however each point is subject to also meeting the additional
 criteria of being true in additionalCriteria.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>abstract int</code></td>
<td class="colLast"><code><strong><a href="../../infodynamics/utils/NearestNeighbourSearcher.html#countPointsWithinR(int,%20double,%20boolean)">countPointsWithinR</a></strong>(int&nbsp;sampleIndex,
                  double&nbsp;r,
                  boolean&nbsp;allowEqualToR)</code>
<div class="block">Count the number of points within norm r for a given
  sample index in the data set.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>abstract int</code></td>
<td class="colLast"><code><strong><a href="../../infodynamics/utils/NearestNeighbourSearcher.html#countPointsWithinR(int,%20double,%20boolean,%20boolean[])">countPointsWithinR</a></strong>(int&nbsp;sampleIndex,
                  double&nbsp;r,
                  boolean&nbsp;allowEqualToR,
                  boolean[]&nbsp;additionalCriteria)</code>
<div class="block">As per <a href="../../infodynamics/utils/NearestNeighbourSearcher.html#countPointsWithinR(int,%20double,%20boolean)"><code>countPointsWithinR(int, double, boolean)</code></a>
 however each point is subject to also meeting the additional
 criteria of being true in additionalCriteria.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>abstract int</code></td>
<td class="colLast"><code><strong><a href="../../infodynamics/utils/NearestNeighbourSearcher.html#countPointsWithinR(int,%20double,%20boolean,%20boolean[],%20int[])">countPointsWithinR</a></strong>(int&nbsp;sampleIndex,
                  double&nbsp;r,
                  boolean&nbsp;allowEqualToR,
                  boolean[]&nbsp;additionalCriteria,
                  int[]&nbsp;remapping)</code>
<div class="block">As per <a href="../../infodynamics/utils/NearestNeighbourSearcher.html#countPointsWithinR(int,%20double,%20boolean)"><code>countPointsWithinR(int, double, boolean)</code></a>
 however each point is subject to also meeting the additional
 criteria of being true in additionalCriteria, 
 and the search points are reindexed according to the remapping
 specified in remapping</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>abstract int</code></td>
<td class="colLast"><code><strong><a href="../../infodynamics/utils/NearestNeighbourSearcher.html#countPointsWithinR(int,%20double,%20int,%20boolean)">countPointsWithinR</a></strong>(int&nbsp;sampleIndex,
                  double&nbsp;r,
                  int&nbsp;dynCorrExclTime,
                  boolean&nbsp;allowEqualToR)</code>
<div class="block">As per <a href="../../infodynamics/utils/NearestNeighbourSearcher.html#countPointsWithinR(int,%20double,%20boolean)"><code>countPointsWithinR(int, double, boolean)</code></a>
 however any nodes within dynCorrExclTime are excluded from
 the search.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static <a href="../../infodynamics/utils/NearestNeighbourSearcher.html" title="class in infodynamics.utils">NearestNeighbourSearcher</a></code></td>
<td class="colLast"><code><strong><a href="../../infodynamics/utils/NearestNeighbourSearcher.html#create(double[][])">create</a></strong>(double[][]&nbsp;data)</code>
<div class="block">Factory method to construct the searcher from a set of double[][] data.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static <a href="../../infodynamics/utils/NearestNeighbourSearcher.html" title="class in infodynamics.utils">NearestNeighbourSearcher</a></code></td>
<td class="colLast"><code><strong><a href="../../infodynamics/utils/NearestNeighbourSearcher.html#create(int[],%20double[][][])">create</a></strong>(int[]&nbsp;dimensions,
      double[][][]&nbsp;data)</code>
<div class="block">Factory method to construct the searcher from a set of double[][][] data.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>abstract java.util.PriorityQueue&lt;<a href="../../infodynamics/utils/NeighbourNodeData.html" title="class in infodynamics.utils">NeighbourNodeData</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="../../infodynamics/utils/NearestNeighbourSearcher.html#findKNearestNeighbours(int,%20int)">findKNearestNeighbours</a></strong>(int&nbsp;K,
                      int&nbsp;sampleIndex)</code>
<div class="block">Return the K nodes which are the K nearest neighbours for a given
  sample index in the data set.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>abstract java.util.PriorityQueue&lt;<a href="../../infodynamics/utils/NeighbourNodeData.html" title="class in infodynamics.utils">NeighbourNodeData</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="../../infodynamics/utils/NearestNeighbourSearcher.html#findKNearestNeighbours(int,%20int,%20int)">findKNearestNeighbours</a></strong>(int&nbsp;K,
                      int&nbsp;sampleIndex,
                      int&nbsp;dynCorrExclTime)</code>
<div class="block">Return the K nodes which are the K nearest neighbours for a given
  sample index in the data set.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>abstract <a href="../../infodynamics/utils/NeighbourNodeData.html" title="class in infodynamics.utils">NeighbourNodeData</a></code></td>
<td class="colLast"><code><strong><a href="../../infodynamics/utils/NearestNeighbourSearcher.html#findNearestNeighbour(int)">findNearestNeighbour</a></strong>(int&nbsp;sampleIndex)</code>
<div class="block">Return the node which is the nearest neighbour for a given
  sample index in the data set.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>java.util.Collection&lt;<a href="../../infodynamics/utils/NeighbourNodeData.html" title="class in infodynamics.utils">NeighbourNodeData</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="../../infodynamics/utils/NearestNeighbourSearcher.html#findPointsStrictlyWithinR(int,%20double)">findPointsStrictlyWithinR</a></strong>(int&nbsp;sampleIndex,
                         double&nbsp;r)</code>
<div class="block">As per <a href="../../infodynamics/utils/NearestNeighbourSearcher.html#findPointsStrictlyWithinR(int,%20double)"><code>findPointsStrictlyWithinR(int, double)</code></a>
 with allowEqualToR == false</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../infodynamics/utils/NearestNeighbourSearcher.html#findPointsStrictlyWithinR(int,%20double,%20boolean[],%20int[])">findPointsStrictlyWithinR</a></strong>(int&nbsp;sampleIndex,
                         double&nbsp;r,
                         boolean[]&nbsp;isWithinR,
                         int[]&nbsp;indicesWithinR)</code>
<div class="block">As per <a href="../../infodynamics/utils/NearestNeighbourSearcher.html#findPointsWithinR(int,%20double,%20boolean,%20boolean[],%20int[])"><code>findPointsWithinR(int, double, boolean, boolean[], int[])</code></a>
 with allowEqualToR == false</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>java.util.Collection&lt;<a href="../../infodynamics/utils/NeighbourNodeData.html" title="class in infodynamics.utils">NeighbourNodeData</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="../../infodynamics/utils/NearestNeighbourSearcher.html#findPointsWithinOrOnR(int,%20double)">findPointsWithinOrOnR</a></strong>(int&nbsp;sampleIndex,
                     double&nbsp;r)</code>
<div class="block">As per <a href="../../infodynamics/utils/NearestNeighbourSearcher.html#findPointsStrictlyWithinR(int,%20double)"><code>findPointsStrictlyWithinR(int, double)</code></a>
 with allowEqualToR == true</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../infodynamics/utils/NearestNeighbourSearcher.html#findPointsWithinOrOnR(int,%20double,%20boolean[],%20int[])">findPointsWithinOrOnR</a></strong>(int&nbsp;sampleIndex,
                     double&nbsp;r,
                     boolean[]&nbsp;isWithinR,
                     int[]&nbsp;indicesWithinR)</code>
<div class="block">As per <a href="../../infodynamics/utils/NearestNeighbourSearcher.html#findPointsWithinR(int,%20double,%20boolean,%20boolean[],%20int[])"><code>findPointsWithinR(int, double, boolean, boolean[], int[])</code></a>
 with allowEqualToR == true</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>abstract void</code></td>
<td class="colLast"><code><strong><a href="../../infodynamics/utils/NearestNeighbourSearcher.html#findPointsWithinR(double,%20double[][],%20boolean,%20boolean[],%20int[])">findPointsWithinR</a></strong>(double&nbsp;r,
                 double[][]&nbsp;sampleVectors,
                 boolean&nbsp;allowEqualToR,
                 boolean[]&nbsp;isWithinR,
                 int[]&nbsp;indicesWithinR)</code>
<div class="block">As per <a href="../../infodynamics/utils/NearestNeighbourSearcher.html#countPointsWithinR(int,%20double,%20boolean)"><code>countPointsWithinR(int, double, boolean)</code></a>
 however records the nearest neighbours for a sample data point
  (which may not be in the search tree), within the isWithinR
  and indicesWithinR arrays, which must be constructed before
  calling this method, with length at or exceeding the total
  number of data points.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>abstract java.util.Collection&lt;<a href="../../infodynamics/utils/NeighbourNodeData.html" title="class in infodynamics.utils">NeighbourNodeData</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="../../infodynamics/utils/NearestNeighbourSearcher.html#findPointsWithinR(int,%20double,%20boolean)">findPointsWithinR</a></strong>(int&nbsp;sampleIndex,
                 double&nbsp;r,
                 boolean&nbsp;allowEqualToR)</code>
<div class="block">As per <a href="../../infodynamics/utils/NearestNeighbourSearcher.html#countPointsWithinR(int,%20double,%20boolean)"><code>countPointsWithinR(int, double, boolean)</code></a>
 however returns a collection rather than a count.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>abstract int</code></td>
<td class="colLast"><code><strong><a href="../../infodynamics/utils/NearestNeighbourSearcher.html#findPointsWithinR(int,%20double,%20boolean,%20boolean[],%20int[])">findPointsWithinR</a></strong>(int&nbsp;sampleIndex,
                 double&nbsp;r,
                 boolean&nbsp;allowEqualToR,
                 boolean[]&nbsp;isWithinR,
                 int[]&nbsp;indicesWithinR)</code>
<div class="block">As per <a href="../../infodynamics/utils/NearestNeighbourSearcher.html#countPointsWithinR(int,%20double,%20boolean)"><code>countPointsWithinR(int, double, boolean)</code></a>
 however records the nearest neighbours made within the isWithinR
  and indicesWithinR arrays, which must be constructed before
  calling this method, with length at or exceeding the total
  number of data points.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>abstract int</code></td>
<td class="colLast"><code><strong><a href="../../infodynamics/utils/NearestNeighbourSearcher.html#findPointsWithinR(int,%20double,%20int,%20boolean,%20boolean[],%20double[],%20double[][])">findPointsWithinR</a></strong>(int&nbsp;sampleIndex,
                 double&nbsp;r,
                 int&nbsp;dynCorrExclTime,
                 boolean&nbsp;allowEqualToR,
                 boolean[]&nbsp;isWithinR,
                 double[]&nbsp;distancesWithinRInOrder,
                 double[][]&nbsp;distancesAndIndicesWithinR)</code>
<div class="block">As per <a href="../../infodynamics/utils/NearestNeighbourSearcher.html#findPointsWithinR(int,%20double,%20boolean,%20boolean[],%20int[])"><code>findPointsWithinR(int, double, boolean, boolean[], int[])</code></a>
 however incorporates dynamic correlation exclusion.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>abstract void</code></td>
<td class="colLast"><code><strong><a href="../../infodynamics/utils/NearestNeighbourSearcher.html#findPointsWithinR(int,%20double,%20int,%20boolean,%20boolean[],%20int[])">findPointsWithinR</a></strong>(int&nbsp;sampleIndex,
                 double&nbsp;r,
                 int&nbsp;dynCorrExclTime,
                 boolean&nbsp;allowEqualToR,
                 boolean[]&nbsp;isWithinR,
                 int[]&nbsp;indicesWithinR)</code>
<div class="block">As per <a href="../../infodynamics/utils/NearestNeighbourSearcher.html#findPointsWithinR(int,%20double,%20boolean,%20boolean[],%20int[])"><code>findPointsWithinR(int, double, boolean, boolean[], int[])</code></a>
 however incorporates dynamic correlation exclusion.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><strong><a href="../../infodynamics/utils/NearestNeighbourSearcher.html#getNormType()">getNormType</a></strong>()</code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>java.lang.String</code></td>
<td class="colLast"><code><strong><a href="../../infodynamics/utils/NearestNeighbourSearcher.html#getNormTypeAsString()">getNormTypeAsString</a></strong>()</code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../infodynamics/utils/NearestNeighbourSearcher.html#setNormType(int)">setNormType</a></strong>(int&nbsp;normType)</code>
<div class="block">Set the norm type to use in the nearest neighbour searches,
  to normType.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../infodynamics/utils/NearestNeighbourSearcher.html#setNormType(java.lang.String)">setNormType</a></strong>(java.lang.String&nbsp;normType)</code>
<div class="block">Set the norm type to use to normType.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><strong><a href="../../infodynamics/utils/NearestNeighbourSearcher.html#validateNormType(java.lang.String)">validateNormType</a></strong>(java.lang.String&nbsp;normType)</code>
<div class="block">Validate whether a specified norm type is supported,
  and return the int corresponding to that type,
  otherwise through an exception.</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods_inherited_from_class_java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<code>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ FIELD DETAIL =========== -->
<ul class="blockList">
<li class="blockList"><a name="field_detail">
<!--   -->
</a>
<h3>Field Detail</h3>
<a name="normTypeToUse">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>normTypeToUse</h4>
<pre>protected&nbsp;int normTypeToUse</pre>
<div class="block">The norm type to use between the univariates.</div>
</li>
</ul>
</li>
</ul>
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor_detail">
<!--   -->
</a>
<h3>Constructor Detail</h3>
<a name="NearestNeighbourSearcher()">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>NearestNeighbourSearcher</h4>
<pre>public&nbsp;NearestNeighbourSearcher()</pre>
</li>
</ul>
</li>
</ul>
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method_detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a name="create(double[][])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>create</h4>
<pre>public static&nbsp;<a href="../../infodynamics/utils/NearestNeighbourSearcher.html" title="class in infodynamics.utils">NearestNeighbourSearcher</a>&nbsp;create(double[][]&nbsp;data)
                                       throws java.lang.Exception</pre>
<div class="block">Factory method to construct the searcher from a set of double[][] data.
 This will return a <a href="../../infodynamics/utils/KdTree.html" title="class in infodynamics.utils"><code>KdTree</code></a> or if the data is univaraite
 (i.e. only one column) a <a href="../../infodynamics/utils/UnivariateNearestNeighbourSearcher.html" title="class in infodynamics.utils"><code>UnivariateNearestNeighbourSearcher</code></a></div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>data</code> - a double[][] 2D data set, first indexed
  by time, second index by variable number.</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code>java.lang.Exception</code></dd></dl>
</li>
</ul>
<a name="create(int[], double[][][])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>create</h4>
<pre>public static&nbsp;<a href="../../infodynamics/utils/NearestNeighbourSearcher.html" title="class in infodynamics.utils">NearestNeighbourSearcher</a>&nbsp;create(int[]&nbsp;dimensions,
                              double[][][]&nbsp;data)
                                       throws java.lang.Exception</pre>
<div class="block">Factory method to construct the searcher from a set of double[][][] data.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>data</code> - an array of double[][] 2D data sets, first indexed
  by time, second index by variable number.</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code>java.lang.Exception</code></dd></dl>
</li>
</ul>
<a name="setNormType(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setNormType</h4>
<pre>public&nbsp;void&nbsp;setNormType(int&nbsp;normType)</pre>
<div class="block">Set the norm type to use in the nearest neighbour searches,
  to normType.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>normType</code> - norm type to use; must be either
  <a href="../../infodynamics/utils/EuclideanUtils.html#NORM_EUCLIDEAN"><code>EuclideanUtils.NORM_EUCLIDEAN</code></a>,
  <a href="../../infodynamics/utils/EuclideanUtils.html#NORM_EUCLIDEAN_SQUARED"><code>EuclideanUtils.NORM_EUCLIDEAN_SQUARED</code></a> or
  <a href="../../infodynamics/utils/EuclideanUtils.html#NORM_MAX_NORM"><code>EuclideanUtils.NORM_MAX_NORM</code></a>, otherwise an
  UnsupportedOperationException is thrown.
  <a href="../../infodynamics/utils/EuclideanUtils.html#NORM_EUCLIDEAN"><code>EuclideanUtils.NORM_EUCLIDEAN</code></a> will be nominally supported
  but switched to
  <a href="../../infodynamics/utils/EuclideanUtils.html#NORM_EUCLIDEAN_SQUARED"><code>EuclideanUtils.NORM_EUCLIDEAN_SQUARED</code></a> internally for speed.</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code>java.lang.UnsupportedOperationException</code> - if the norm type is not
  one of the above supported options.</dd></dl>
</li>
</ul>
<a name="setNormType(java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setNormType</h4>
<pre>public&nbsp;void&nbsp;setNormType(java.lang.String&nbsp;normType)</pre>
<div class="block">Set the norm type to use to normType.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>normType</code> - norm type to use; must be either
  <a href="../../infodynamics/utils/EuclideanUtils.html#NORM_EUCLIDEAN_STRING"><code>EuclideanUtils.NORM_EUCLIDEAN_STRING</code></a>,
  <a href="../../infodynamics/utils/EuclideanUtils.html#NORM_EUCLIDEAN_SQUARED_STRING"><code>EuclideanUtils.NORM_EUCLIDEAN_SQUARED_STRING</code></a> or
  <a href="../../infodynamics/utils/EuclideanUtils.html#NORM_MAX_NORM_STRING"><code>EuclideanUtils.NORM_MAX_NORM_STRING</code></a>, otherwise an
  UnsupportedOperationException is thrown.
  <a href="../../infodynamics/utils/EuclideanUtils.html#NORM_EUCLIDEAN"><code>EuclideanUtils.NORM_EUCLIDEAN</code></a> will be nominally supported
  but switched to
  <a href="../../infodynamics/utils/EuclideanUtils.html#NORM_EUCLIDEAN_SQUARED"><code>EuclideanUtils.NORM_EUCLIDEAN_SQUARED</code></a> internally for speed.</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code>java.lang.UnsupportedOperationException</code> - if the norm type is not
  one of the above supported options.</dd></dl>
</li>
</ul>
<a name="getNormType()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getNormType</h4>
<pre>public&nbsp;int&nbsp;getNormType()</pre>
<dl><dt><span class="strong">Returns:</span></dt><dd>the norm type in use</dd></dl>
</li>
</ul>
<a name="getNormTypeAsString()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getNormTypeAsString</h4>
<pre>public&nbsp;java.lang.String&nbsp;getNormTypeAsString()</pre>
<dl><dt><span class="strong">Returns:</span></dt><dd>the norm type in use as a String</dd></dl>
</li>
</ul>
<a name="validateNormType(java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>validateNormType</h4>
<pre>public static&nbsp;int&nbsp;validateNormType(java.lang.String&nbsp;normType)</pre>
<div class="block">Validate whether a specified norm type is supported,
  and return the int corresponding to that type,
  otherwise through an exception.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>normType</code> - norm type to use; must be either
  <a href="../../infodynamics/utils/EuclideanUtils.html#NORM_EUCLIDEAN_STRING"><code>EuclideanUtils.NORM_EUCLIDEAN_STRING</code></a>,
  <a href="../../infodynamics/utils/EuclideanUtils.html#NORM_EUCLIDEAN_SQUARED_STRING"><code>EuclideanUtils.NORM_EUCLIDEAN_SQUARED_STRING</code></a> or
  <a href="../../infodynamics/utils/EuclideanUtils.html#NORM_MAX_NORM_STRING"><code>EuclideanUtils.NORM_MAX_NORM_STRING</code></a>, otherwise an
  UnsupportedOperationException is thrown.
  <a href="../../infodynamics/utils/EuclideanUtils.html#NORM_EUCLIDEAN"><code>EuclideanUtils.NORM_EUCLIDEAN</code></a> will be nominally supported
  but switched to
  <a href="../../infodynamics/utils/EuclideanUtils.html#NORM_EUCLIDEAN_SQUARED"><code>EuclideanUtils.NORM_EUCLIDEAN_SQUARED</code></a> internally for speed.</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code>java.lang.UnsupportedOperationException</code> - if the norm type is not
  one of the above supported options.</dd></dl>
</li>
</ul>
<a name="convertNormTypeToString(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>convertNormTypeToString</h4>
<pre>public static&nbsp;java.lang.String&nbsp;convertNormTypeToString(int&nbsp;normType)</pre>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>an</code> - identifier for a norm type</dd>
<dt><span class="strong">Returns:</span></dt><dd>representation of that norm type as a String</dd></dl>
</li>
</ul>
<a name="findNearestNeighbour(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findNearestNeighbour</h4>
<pre>public abstract&nbsp;<a href="../../infodynamics/utils/NeighbourNodeData.html" title="class in infodynamics.utils">NeighbourNodeData</a>&nbsp;findNearestNeighbour(int&nbsp;sampleIndex)</pre>
<div class="block">Return the node which is the nearest neighbour for a given
  sample index in the data set. The node itself is 
  excluded from the search.
 Nearest neighbour function to compare to r is a max norm between the
 high-level variables, with norm for each variable being the specified norm.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>sampleIndex</code> - sample index in the data to find a nearest neighbour
  for</dd>
<dt><span class="strong">Returns:</span></dt><dd>the node for the nearest neighbour.</dd></dl>
</li>
</ul>
<a name="findKNearestNeighbours(int, int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findKNearestNeighbours</h4>
<pre>public abstract&nbsp;java.util.PriorityQueue&lt;<a href="../../infodynamics/utils/NeighbourNodeData.html" title="class in infodynamics.utils">NeighbourNodeData</a>&gt;&nbsp;findKNearestNeighbours(int&nbsp;K,
                                                                int&nbsp;sampleIndex)
                                                                           throws java.lang.Exception</pre>
<div class="block">Return the K nodes which are the K nearest neighbours for a given
  sample index in the data set. The node itself is 
  excluded from the search.
 Nearest neighbour function to compare to r is a max norm between the
 high-level variables, with norm for each variable being the specified norm.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>K</code> - number of K nearest neighbours to return, sorted from
  furthest away first to nearest last.</dd><dd><code>sampleIndex</code> - sample index in the data to find the K nearest neighbours
  for</dd>
<dt><span class="strong">Returns:</span></dt><dd>a PriorityQueue of nodes for the K nearest neighbours,
  sorted with furthest neighbour first in the PQ.</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code>java.lang.Exception</code></dd></dl>
</li>
</ul>
<a name="findKNearestNeighbours(int, int, int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findKNearestNeighbours</h4>
<pre>public abstract&nbsp;java.util.PriorityQueue&lt;<a href="../../infodynamics/utils/NeighbourNodeData.html" title="class in infodynamics.utils">NeighbourNodeData</a>&gt;&nbsp;findKNearestNeighbours(int&nbsp;K,
                                                                int&nbsp;sampleIndex,
                                                                int&nbsp;dynCorrExclTime)
                                                                           throws java.lang.Exception</pre>
<div class="block">Return the K nodes which are the K nearest neighbours for a given
  sample index in the data set. Nodes within dynCorrExclTime time points
  are excluded from the search.
 Nearest neighbour function to compare to r is a max norm between the
 high-level variables, with norm for each variable being the specified norm.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>K</code> - number of K nearest neighbours to return, sorted from
  furthest away first to nearest last.</dd><dd><code>sampleIndex</code> - sample index in the data to find the K nearest neighbours
  for</dd><dd><code>dynCorrExclTime</code> - Range around sampleIndex to exclude points from the count. Is >= 0.</dd>
<dt><span class="strong">Returns:</span></dt><dd>a PriorityQueue of nodes for the K nearest neighbours,
  sorted with furthest neighbour first in the PQ.</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code>java.lang.Exception</code></dd></dl>
</li>
</ul>
<a name="countPointsWithinR(int, double, boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>countPointsWithinR</h4>
<pre>public abstract&nbsp;int&nbsp;countPointsWithinR(int&nbsp;sampleIndex,
                     double&nbsp;r,
                     boolean&nbsp;allowEqualToR)</pre>
<div class="block">Count the number of points within norm r for a given
  sample index in the data set. The node itself is 
  excluded from the search.
 Nearest neighbour function to compare to r is a max norm between the
 high-level variables, with norm for each variable being the specified norm.
 (If <a href="../../infodynamics/utils/EuclideanUtils.html#NORM_EUCLIDEAN"><code>EuclideanUtils.NORM_EUCLIDEAN</code></a> was selected, then the supplied
 r should be the required Euclidean norm <b>squared</b>, since we switch it
 to <a href="../../infodynamics/utils/EuclideanUtils.html#NORM_EUCLIDEAN_SQUARED"><code>EuclideanUtils.NORM_EUCLIDEAN_SQUARED</code></a> internally).</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>sampleIndex</code> - sample index in the data to find a nearest neighbour
  for</dd><dd><code>r</code> - radius within which to count points</dd><dd><code>allowEqualToR</code> - if true, then count points at radius r also,
   otherwise only those strictly within r</dd>
<dt><span class="strong">Returns:</span></dt><dd>the count of points within r.</dd></dl>
</li>
</ul>
<a name="countPointsWithinR(int, double, int, boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>countPointsWithinR</h4>
<pre>public abstract&nbsp;int&nbsp;countPointsWithinR(int&nbsp;sampleIndex,
                     double&nbsp;r,
                     int&nbsp;dynCorrExclTime,
                     boolean&nbsp;allowEqualToR)</pre>
<div class="block">As per <a href="../../infodynamics/utils/NearestNeighbourSearcher.html#countPointsWithinR(int,%20double,%20boolean)"><code>countPointsWithinR(int, double, boolean)</code></a>
 however any nodes within dynCorrExclTime are excluded from
 the search.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>sampleIndex</code> - sample index in the data to find a nearest neighbour
  for</dd><dd><code>r</code> - radius within which to count points</dd><dd><code>dynCorrExclTime</code> - time window within which to exclude
  points to be counted. Is >= 0. 0 means only exclude sampleIndex.</dd><dd><code>allowEqualToR</code> - if true, then count points at radius r also,
   otherwise only those strictly within r</dd>
<dt><span class="strong">Returns:</span></dt><dd>the count of points within r.</dd></dl>
</li>
</ul>
<a name="countPointsWithinR(double[][], double, boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>countPointsWithinR</h4>
<pre>public abstract&nbsp;int&nbsp;countPointsWithinR(double[][]&nbsp;sampleVectors,
                     double&nbsp;r,
                     boolean&nbsp;allowEqualToR)</pre>
<div class="block">As per <a href="../../infodynamics/utils/NearestNeighbourSearcher.html#countPointsWithinR(int,%20double,%20boolean)"><code>countPointsWithinR(int, double, boolean)</code></a>
 however the search is to match a specified sample point (not a sample
 point within the search space itself).</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>sampleVectors</code> - sample vectors to find the neighbours within r
  for</dd><dd><code>r</code> - radius within which to count points</dd><dd><code>dynCorrExclTime</code> - time window within which to exclude
  points to be counted. Is >= 0. 0 means only exclude sampleIndex.</dd><dd><code>allowEqualToR</code> - if true, then count points at radius r also,
   otherwise only those strictly within r</dd>
<dt><span class="strong">Returns:</span></dt><dd>the count of points within r.</dd></dl>
</li>
</ul>
<a name="findPointsWithinR(int, double, boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findPointsWithinR</h4>
<pre>public abstract&nbsp;java.util.Collection&lt;<a href="../../infodynamics/utils/NeighbourNodeData.html" title="class in infodynamics.utils">NeighbourNodeData</a>&gt;&nbsp;findPointsWithinR(int&nbsp;sampleIndex,
                                                        double&nbsp;r,
                                                        boolean&nbsp;allowEqualToR)</pre>
<div class="block">As per <a href="../../infodynamics/utils/NearestNeighbourSearcher.html#countPointsWithinR(int,%20double,%20boolean)"><code>countPointsWithinR(int, double, boolean)</code></a>
 however returns a collection rather than a count.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>sampleIndex</code> - sample index in the data to find a nearest neighbour
  for</dd><dd><code>r</code> - radius within which to count points</dd><dd><code>allowEqualToR</code> - if true, then count points at radius r also,
   otherwise only those strictly within r</dd>
<dt><span class="strong">Returns:</span></dt><dd>the collection of points within r.</dd></dl>
</li>
</ul>
<a name="findPointsWithinR(int, double, boolean, boolean[], int[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findPointsWithinR</h4>
<pre>public abstract&nbsp;int&nbsp;findPointsWithinR(int&nbsp;sampleIndex,
                    double&nbsp;r,
                    boolean&nbsp;allowEqualToR,
                    boolean[]&nbsp;isWithinR,
                    int[]&nbsp;indicesWithinR)</pre>
<div class="block">As per <a href="../../infodynamics/utils/NearestNeighbourSearcher.html#countPointsWithinR(int,%20double,%20boolean)"><code>countPointsWithinR(int, double, boolean)</code></a>
 however records the nearest neighbours made within the isWithinR
  and indicesWithinR arrays, which must be constructed before
  calling this method, with length at or exceeding the total
  number of data points. indicesWithinR is 
 </p></div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>sampleIndex</code> - sample index in the data to find a nearest neighbour
  for</dd><dd><code>r</code> - radius within which to count points</dd><dd><code>allowEqualToR</code> - if true, then count points at radius r also,
   otherwise only those strictly within r</dd><dd><code>isWithinR</code> - the array MUST be passed in with all points set to
  false initially, and is returned indicating whether each sample was
  found to be within r of that at sampleIndex.</dd><dd><code>indicesWithinR</code> - a list of array indices
  for points marked as true in isWithinR, terminated with a -1 value.</dd>
<dt><span class="strong">Returns:</span></dt><dd>the number of matching points found</dd></dl>
</li>
</ul>
<a name="findPointsWithinR(int, double, int, boolean, boolean[], int[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findPointsWithinR</h4>
<pre>public abstract&nbsp;void&nbsp;findPointsWithinR(int&nbsp;sampleIndex,
                     double&nbsp;r,
                     int&nbsp;dynCorrExclTime,
                     boolean&nbsp;allowEqualToR,
                     boolean[]&nbsp;isWithinR,
                     int[]&nbsp;indicesWithinR)</pre>
<div class="block">As per <a href="../../infodynamics/utils/NearestNeighbourSearcher.html#findPointsWithinR(int,%20double,%20boolean,%20boolean[],%20int[])"><code>findPointsWithinR(int, double, boolean, boolean[], int[])</code></a>
 however incorporates dynamic correlation exclusion.
 </p></div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>sampleIndex</code> - sample index in the data to find a nearest neighbour
  for</dd><dd><code>r</code> - radius within which to count points</dd><dd><code>dynCorrExclTime</code> - time window within which to exclude
  points to be counted. Is >= 0. 0 means only exclude sampleIndex.</dd><dd><code>allowEqualToR</code> - if true, then count points at radius r also,
   otherwise only those strictly within r</dd><dd><code>isWithinR</code> - the array MUST be passed in with all points set to
  false initially, and is returned indicating whether each sample was
  found to be within r of that at sampleIndex.</dd><dd><code>indicesWithinR</code> - a list of array indices
  for points marked as true in isWithinR, terminated with a -1 value.</dd></dl>
</li>
</ul>
<a name="findPointsWithinR(int, double, int, boolean, boolean[], double[], double[][])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findPointsWithinR</h4>
<pre>public abstract&nbsp;int&nbsp;findPointsWithinR(int&nbsp;sampleIndex,
                    double&nbsp;r,
                    int&nbsp;dynCorrExclTime,
                    boolean&nbsp;allowEqualToR,
                    boolean[]&nbsp;isWithinR,
                    double[]&nbsp;distancesWithinRInOrder,
                    double[][]&nbsp;distancesAndIndicesWithinR)</pre>
<div class="block">As per <a href="../../infodynamics/utils/NearestNeighbourSearcher.html#findPointsWithinR(int,%20double,%20boolean,%20boolean[],%20int[])"><code>findPointsWithinR(int, double, boolean, boolean[], int[])</code></a>
 however incorporates dynamic correlation exclusion.
 </p></div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>sampleIndex</code> - sample index in the data to find a nearest neighbour
  for</dd><dd><code>r</code> - radius within which to count points</dd><dd><code>dynCorrExclTime</code> - time window within which to exclude
  points to be counted. Is >= 0. 0 means only exclude sampleIndex.</dd><dd><code>allowEqualToR</code> - if true, then count points at radius r also,
   otherwise only those strictly within r</dd><dd><code>isWithinR</code> - the array MUST be passed in with all points set to
  false initially, and is returned indicating whether each sample was
  found to be within r of that at sampleIndex.</dd><dd><code>distancesWithinRInOrder</code> - the array must be passed in and is
  returned with distances for each point found to be within r. Values
  at other indices are not defined.</dd><dd><code>distancesAndIndicesWithinR</code> - is returned as 
  a list of distances (in column index 0) 
  and array indices (in column index 1)
  for points marked as true in isWithinR, terminated with a -1 value on the index.</dd>
<dt><span class="strong">Returns:</span></dt><dd>the point count</dd></dl>
</li>
</ul>
<a name="findPointsWithinR(double, double[][], boolean, boolean[], int[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findPointsWithinR</h4>
<pre>public abstract&nbsp;void&nbsp;findPointsWithinR(double&nbsp;r,
                     double[][]&nbsp;sampleVectors,
                     boolean&nbsp;allowEqualToR,
                     boolean[]&nbsp;isWithinR,
                     int[]&nbsp;indicesWithinR)</pre>
<div class="block">As per <a href="../../infodynamics/utils/NearestNeighbourSearcher.html#countPointsWithinR(int,%20double,%20boolean)"><code>countPointsWithinR(int, double, boolean)</code></a>
 however records the nearest neighbours for a sample data point
  (which may not be in the search tree), within the isWithinR
  and indicesWithinR arrays, which must be constructed before
  calling this method, with length at or exceeding the total
  number of data points. indicesWithinR is 
 </p></div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>r</code> - radius within which to count points</dd><dd><code>sampleVectors</code> - sample vectors to find the neighbours within r
  for</dd><dd><code>allowEqualToR</code> - if true, then count points at radius r also,
   otherwise only those strictly within r</dd><dd><code>isWithinR</code> - the array MUST be passed in with all points set to
  false initially, and is returned indicating whether each sample was
  found to be within r of that at sampleIndex.</dd><dd><code>indicesWithinR</code> - a list of array indices
  for points marked as true in isWithinR, terminated with a -1 value.</dd></dl>
</li>
</ul>
<a name="countPointsStrictlyWithinR(int, double, int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>countPointsStrictlyWithinR</h4>
<pre>public&nbsp;int&nbsp;countPointsStrictlyWithinR(int&nbsp;sampleIndex,
                             double&nbsp;r,
                             int&nbsp;dynCorrExclTime)</pre>
<div class="block">As per <a href="../../infodynamics/utils/NearestNeighbourSearcher.html#countPointsWithinR(int,%20double,%20int,%20boolean)"><code>countPointsWithinR(int, double, int, boolean)</code></a>
 with allowEqualToR == false</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>sampleIndex</code> - sample index in the data to find a nearest neighbour
  for</dd><dd><code>r</code> - radius within which to count points</dd><dd><code>dynCorrExclTime</code> - time window within which to exclude
  points to be counted. Is >= 0. 0 means only exclude sampleIndex.</dd>
<dt><span class="strong">Returns:</span></dt><dd>the count of points within r.</dd></dl>
</li>
</ul>
<a name="countPointsStrictlyWithinR(int, double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>countPointsStrictlyWithinR</h4>
<pre>public&nbsp;int&nbsp;countPointsStrictlyWithinR(int&nbsp;sampleIndex,
                             double&nbsp;r)</pre>
<div class="block">As per <a href="../../infodynamics/utils/NearestNeighbourSearcher.html#countPointsWithinR(int,%20double,%20boolean)"><code>countPointsWithinR(int, double, boolean)</code></a>
 with allowEqualToR == false</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>sampleIndex</code> - sample index in the data to find a nearest neighbour
  for</dd><dd><code>r</code> - radius within which to count points</dd>
<dt><span class="strong">Returns:</span></dt><dd>the count of points within r.</dd></dl>
</li>
</ul>
<a name="findPointsStrictlyWithinR(int, double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findPointsStrictlyWithinR</h4>
<pre>public&nbsp;java.util.Collection&lt;<a href="../../infodynamics/utils/NeighbourNodeData.html" title="class in infodynamics.utils">NeighbourNodeData</a>&gt;&nbsp;findPointsStrictlyWithinR(int&nbsp;sampleIndex,
                                                                double&nbsp;r)</pre>
<div class="block">As per <a href="../../infodynamics/utils/NearestNeighbourSearcher.html#findPointsStrictlyWithinR(int,%20double)"><code>findPointsStrictlyWithinR(int, double)</code></a>
 with allowEqualToR == false</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>sampleIndex</code> - sample index in the data to find a nearest neighbour
  for</dd><dd><code>r</code> - radius within which to count points</dd>
<dt><span class="strong">Returns:</span></dt><dd>the collection of points within r.</dd></dl>
</li>
</ul>
<a name="findPointsStrictlyWithinR(int, double, boolean[], int[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findPointsStrictlyWithinR</h4>
<pre>public&nbsp;void&nbsp;findPointsStrictlyWithinR(int&nbsp;sampleIndex,
                             double&nbsp;r,
                             boolean[]&nbsp;isWithinR,
                             int[]&nbsp;indicesWithinR)</pre>
<div class="block">As per <a href="../../infodynamics/utils/NearestNeighbourSearcher.html#findPointsWithinR(int,%20double,%20boolean,%20boolean[],%20int[])"><code>findPointsWithinR(int, double, boolean, boolean[], int[])</code></a>
 with allowEqualToR == false</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>sampleIndex</code> - sample index in the data to find a nearest neighbour
  for</dd><dd><code>r</code> - radius within which to count points</dd><dd><code>isWithinR</code> - the array should be passed in with all points set to
  false initially, and is return indicating whether each sample was
  found to be within r of that at sampleIndex.</dd><dd><code>indicesWithinR</code> - a list of array indices
  for points marked as true in isWithinR, terminated with a -1 value.</dd></dl>
</li>
</ul>
<a name="countPointsWithinOrOnR(int, double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>countPointsWithinOrOnR</h4>
<pre>public&nbsp;int&nbsp;countPointsWithinOrOnR(int&nbsp;sampleIndex,
                         double&nbsp;r)</pre>
<div class="block">As per <a href="../../infodynamics/utils/NearestNeighbourSearcher.html#countPointsWithinR(int,%20double,%20boolean)"><code>countPointsWithinR(int, double, boolean)</code></a>
 with allowEqualToR == true</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>sampleIndex</code> - sample index in the data to find a nearest neighbour
  for</dd><dd><code>r</code> - radius within which to count points</dd>
<dt><span class="strong">Returns:</span></dt><dd>the count of points within or on r.</dd></dl>
</li>
</ul>
<a name="countPointsWithinOrOnR(int, double, int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>countPointsWithinOrOnR</h4>
<pre>public&nbsp;int&nbsp;countPointsWithinOrOnR(int&nbsp;sampleIndex,
                         double&nbsp;r,
                         int&nbsp;dynCorrExclTime)</pre>
<div class="block">As per <a href="../../infodynamics/utils/NearestNeighbourSearcher.html#countPointsWithinR(int,%20double,%20int,%20boolean)"><code>countPointsWithinR(int, double, int, boolean)</code></a>
 with allowEqualToR == true</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>sampleIndex</code> - sample index in the data to find a nearest neighbour
  for</dd><dd><code>r</code> - radius within which to count points</dd><dd><code>dynCorrExclTime</code> - time window within which to exclude
  points to be counted. Is >= 0. 0 means only exclude sampleIndex.</dd>
<dt><span class="strong">Returns:</span></dt><dd>the count of points within or on r.</dd></dl>
</li>
</ul>
<a name="findPointsWithinOrOnR(int, double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findPointsWithinOrOnR</h4>
<pre>public&nbsp;java.util.Collection&lt;<a href="../../infodynamics/utils/NeighbourNodeData.html" title="class in infodynamics.utils">NeighbourNodeData</a>&gt;&nbsp;findPointsWithinOrOnR(int&nbsp;sampleIndex,
                                                            double&nbsp;r)</pre>
<div class="block">As per <a href="../../infodynamics/utils/NearestNeighbourSearcher.html#findPointsStrictlyWithinR(int,%20double)"><code>findPointsStrictlyWithinR(int, double)</code></a>
 with allowEqualToR == true</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>sampleIndex</code> - sample index in the data to find a nearest neighbour
  for</dd><dd><code>r</code> - radius within which to count points</dd>
<dt><span class="strong">Returns:</span></dt><dd>the collection of points within or on r.</dd></dl>
</li>
</ul>
<a name="findPointsWithinOrOnR(int, double, boolean[], int[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findPointsWithinOrOnR</h4>
<pre>public&nbsp;void&nbsp;findPointsWithinOrOnR(int&nbsp;sampleIndex,
                         double&nbsp;r,
                         boolean[]&nbsp;isWithinR,
                         int[]&nbsp;indicesWithinR)</pre>
<div class="block">As per <a href="../../infodynamics/utils/NearestNeighbourSearcher.html#findPointsWithinR(int,%20double,%20boolean,%20boolean[],%20int[])"><code>findPointsWithinR(int, double, boolean, boolean[], int[])</code></a>
 with allowEqualToR == true</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>sampleIndex</code> - sample index in the data to find a nearest neighbour
  for</dd><dd><code>r</code> - radius within which to count points</dd><dd><code>isWithinR</code> - the array should be passed in with all points set to
  false initially, and is return indicating whether each sample was
  found to be within r of that at sampleIndex.</dd><dd><code>indicesWithinR</code> - a list of array indices
  for points marked as true in isWithinR, terminated with a -1 value.</dd></dl>
</li>
</ul>
<a name="countPointsWithinR(int, double, boolean, boolean[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>countPointsWithinR</h4>
<pre>public abstract&nbsp;int&nbsp;countPointsWithinR(int&nbsp;sampleIndex,
                     double&nbsp;r,
                     boolean&nbsp;allowEqualToR,
                     boolean[]&nbsp;additionalCriteria)</pre>
<div class="block">As per <a href="../../infodynamics/utils/NearestNeighbourSearcher.html#countPointsWithinR(int,%20double,%20boolean)"><code>countPointsWithinR(int, double, boolean)</code></a>
 however each point is subject to also meeting the additional
 criteria of being true in additionalCriteria.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>sampleIndex</code> - sample index in the data to find a nearest neighbour
  for</dd><dd><code>r</code> - radius within which to count points</dd><dd><code>allowEqualToR</code> - if true, then count points at radius r also,
   otherwise only those strictly within r</dd><dd><code>additionalCriteria</code> - array of booleans. Only count a point if it
  is within r and is true in additionalCrtieria.</dd>
<dt><span class="strong">Returns:</span></dt><dd>the count of points within r.</dd></dl>
</li>
</ul>
<a name="countPointsWithinR(int, double, boolean, boolean[], int[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>countPointsWithinR</h4>
<pre>public abstract&nbsp;int&nbsp;countPointsWithinR(int&nbsp;sampleIndex,
                     double&nbsp;r,
                     boolean&nbsp;allowEqualToR,
                     boolean[]&nbsp;additionalCriteria,
                     int[]&nbsp;remapping)</pre>
<div class="block">As per <a href="../../infodynamics/utils/NearestNeighbourSearcher.html#countPointsWithinR(int,%20double,%20boolean)"><code>countPointsWithinR(int, double, boolean)</code></a>
 however each point is subject to also meeting the additional
 criteria of being true in additionalCriteria, 
 and the search points are reindexed according to the remapping
 specified in remapping</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>sampleIndex</code> - sample index in the data to find a nearest neighbour
  for (already remapped if required)</dd><dd><code>r</code> - radius within which to count points</dd><dd><code>allowEqualToR</code> - if true, then count points at radius r also,
   otherwise only those strictly within r</dd><dd><code>additionalCriteria</code> - array of booleans. Only count a point if it
  is within r and is true in additionalCrtieria.</dd><dd><code>remapping</code> - array of time indices with which to remap the search points
  onto the same time index space as the additionalCriteria (this will
  apply to the supplied sampleIndex as well as other search points)</dd>
<dt><span class="strong">Returns:</span></dt><dd>the count of points within r.</dd></dl>
</li>
</ul>
<a name="countPointsWithinR(double[][], double, boolean, boolean[])">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>countPointsWithinR</h4>
<pre>public abstract&nbsp;int&nbsp;countPointsWithinR(double[][]&nbsp;sampleVectors,
                     double&nbsp;r,
                     boolean&nbsp;allowEqualToR,
                     boolean[]&nbsp;additionalCriteria)</pre>
<div class="block">As per <a href="../../infodynamics/utils/NearestNeighbourSearcher.html#countPointsWithinR(double[][],%20double,%20boolean)"><code>countPointsWithinR(double[][], double, boolean)</code></a>
 however each point is subject to also meeting the additional
 criteria of being true in additionalCriteria.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>sampleVectors</code> - sample vectors to find the neighbours within r
  for</dd><dd><code>r</code> - radius within which to count points</dd><dd><code>allowEqualToR</code> - if true, then count points at radius r also,
   otherwise only those strictly within r</dd><dd><code>additionalCriteria</code> - array of booleans. Only count a point if it
  is within r and is true in additionalCrtieria.</dd>
<dt><span class="strong">Returns:</span></dt><dd>the count of points within r.</dd></dl>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<!-- ========= END OF CLASS DATA ========= -->
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar_bottom">
<!--   -->
</a><a href="#skip-navbar_bottom" title="Skip navigation links"></a><a name="navbar_bottom_firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../index-all.html">Index</a></li>
<li><a href="../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../infodynamics/utils/NativeUtils.html" title="class in infodynamics.utils"><span class="strong">Prev Class</span></a></li>
<li><a href="../../infodynamics/utils/NeighbourNodeData.html" title="class in infodynamics.utils"><span class="strong">Next Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../index.html?infodynamics/utils/NearestNeighbourSearcher.html" target="_top">Frames</a></li>
<li><a href="NearestNeighbourSearcher.html" target="_top">No Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../allclasses-noframe.html">All Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field_summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor_summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method_summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field_detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor_detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method_detail">Method</a></li>
</ul>
</div>
<a name="skip-navbar_bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</body>
</html>
